# Neo4j Graph Schema for Fraud Detection

## Overview

This document outlines the Neo4j graph schema design for the credit card fraud detection system. The graph model is designed to capture the relationships between entities involved in credit card transactions and enable efficient pattern detection for fraud analysis.

## Graph Data Model

### Node Labels

1. **User**
   - Represents a customer who owns one or more credit cards
   
2. **Card**
   - Represents a credit card issued to a user
   
3. **Transaction**
   - Represents a credit card transaction
   
4. **Merchant**
   - Represents a business where transactions occur
   
5. **Location**
   - Represents a geographic location where transactions occur
   
6. **Device**
   - Represents a device used for online transactions
   
7. **IPAddress**
   - Represents an IP address associated with online transactions
   
8. **FraudPattern**
   - Represents a known fraud pattern for reference
   
9. **Alert**
   - Represents a fraud alert generated by the system

### Relationship Types

1. **OWNS**
   - (User)-[:OWNS]->(Card)
   - Indicates ownership of a card by a user
   
2. **MADE**
   - (Card)-[:MADE]->(Transaction)
   - Connects a card to a transaction
   
3. **AT**
   - (Transaction)-[:AT]->(Merchant)
   - Indicates where a transaction occurred
   
4. **IN**
   - (Transaction)-[:IN]->(Location)
   - Indicates the location of a transaction
   
5. **USING**
   - (Transaction)-[:USING]->(Device)
   - Connects a transaction to the device used
   
6. **FROM**
   - (Device)-[:FROM]->(IPAddress)
   - Connects a device to its IP address
   
7. **FOLLOWED_BY**
   - (Transaction)-[:FOLLOWED_BY]->(Transaction)
   - Temporal relationship between consecutive transactions
   
8. **SIMILAR_TO**
   - (Transaction)-[:SIMILAR_TO]->(FraudPattern)
   - Indicates similarity to a known fraud pattern
   
9. **TRIGGERED**
   - (Transaction)-[:TRIGGERED]->(Alert)
   - Connects a transaction to alerts it triggered
   
10. **FLAGGED**
    - (Alert)-[:FLAGGED]->(Transaction)
    - Indicates a transaction flagged by an alert
    
11. **FREQUENTLY_VISITS**
    - (User)-[:FREQUENTLY_VISITS]->(Merchant)
    - Indicates merchants frequently visited by a user
    
12. **TYPICALLY_IN**
    - (User)-[:TYPICALLY_IN]->(Location)
    - Indicates locations where a user typically transacts

## Node Properties

### User
```
{
  userId: String,
  name: String,
  email: String,
  phone: String,
  riskScore: Float,
  accountCreationDate: DateTime,
  lastActivityDate: DateTime,
  fraudHistory: Boolean,
  kycVerified: Boolean
}
```

### Card
```
{
  cardId: String,
  cardType: String,
  issueDate: DateTime,
  expiryDate: DateTime,
  lastFourDigits: String,
  isActive: Boolean,
  isBlocked: Boolean,
  creditLimit: Float,
  availableCredit: Float
}
```

### Transaction
```
{
  transactionId: String,
  timestamp: DateTime,
  amount: Float,
  currency: String,
  status: String,
  transactionType: String,
  paymentMethod: String,
  isOnline: Boolean,
  isFraudulent: Boolean,
  fraudScore: Float,
  mcc: String,  // Merchant Category Code
  authCode: String,
  responseCode: String,
  isDeclined: Boolean,
  declineReason: String
}
```

### Merchant
```
{
  merchantId: String,
  name: String,
  category: String,
  mcc: String,
  website: String,
  country: String,
  riskScore: Float,
  fraudRate: Float,
  avgTransactionAmount: Float,
  isHighRisk: Boolean
}
```

### Location
```
{
  locationId: String,
  latitude: Float,
  longitude: Float,
  country: String,
  city: String,
  postalCode: String,
  address: String,
  timezone: String,
  riskScore: Float
}
```

### Device
```
{
  deviceId: String,
  deviceType: String,
  browser: String,
  operatingSystem: String,
  fingerprint: String,
  isMobile: Boolean,
  isKnownDevice: Boolean,
  riskScore: Float
}
```

### IPAddress
```
{
  ip: String,
  country: String,
  city: String,
  isp: String,
  isProxy: Boolean,
  isVpn: Boolean,
  isTor: Boolean,
  riskScore: Float
}
```

### FraudPattern
```
{
  patternId: String,
  description: String,
  confidence: Float,
  discoveryDate: DateTime,
  patternType: String,
  isActive: Boolean
}
```

### Alert
```
{
  alertId: String,
  timestamp: DateTime,
  severity: String,
  type: String,
  description: String,
  isResolved: Boolean,
  resolutionNotes: String
}
```

## Relationship Properties

### MADE
```
{
  timestamp: DateTime
}
```

### FOLLOWED_BY
```
{
  timeDifference: Long,  // in seconds
  distanceDifference: Float,  // in kilometers
  velocityAnomaly: Boolean
}
```

### SIMILAR_TO
```
{
  similarityScore: Float,
  matchedFeatures: String[]
}
```

### TRIGGERED
```
{
  reason: String,
  confidence: Float
}
```

### FREQUENTLY_VISITS
```
{
  frequency: Integer,  // number of visits
  lastVisit: DateTime,
  averageSpend: Float
}
```

## Indexes and Constraints

### Unique Constraints
```cypher
CREATE CONSTRAINT user_id_unique IF NOT EXISTS
FOR (u:User) REQUIRE u.userId IS UNIQUE;

CREATE CONSTRAINT card_id_unique IF NOT EXISTS
FOR (c:Card) REQUIRE c.cardId IS UNIQUE;

CREATE CONSTRAINT transaction_id_unique IF NOT EXISTS
FOR (t:Transaction) REQUIRE t.transactionId IS UNIQUE;

CREATE CONSTRAINT merchant_id_unique IF NOT EXISTS
FOR (m:Merchant) REQUIRE m.merchantId IS UNIQUE;

CREATE CONSTRAINT device_id_unique IF NOT EXISTS
FOR (d:Device) REQUIRE d.deviceId IS UNIQUE;

CREATE CONSTRAINT ip_unique IF NOT EXISTS
FOR (i:IPAddress) REQUIRE i.ip IS UNIQUE;

CREATE CONSTRAINT alert_id_unique IF NOT EXISTS
FOR (a:Alert) REQUIRE a.alertId IS UNIQUE;
```

### Indexes
```cypher
CREATE INDEX user_email_idx IF NOT EXISTS FOR (u:User) ON (u.email);
CREATE INDEX card_last_four_idx IF NOT EXISTS FOR (c:Card) ON (c.lastFourDigits);
CREATE INDEX transaction_timestamp_idx IF NOT EXISTS FOR (t:Transaction) ON (t.timestamp);
CREATE INDEX merchant_name_idx IF NOT EXISTS FOR (m:Merchant) ON (m.name);
CREATE INDEX merchant_category_idx IF NOT EXISTS FOR (m:Merchant) ON (m.category);
CREATE INDEX location_country_idx IF NOT EXISTS FOR (l:Location) ON (l.country);
CREATE INDEX device_fingerprint_idx IF NOT EXISTS FOR (d:Device) ON (d.fingerprint);
CREATE INDEX ip_country_idx IF NOT EXISTS FOR (i:IPAddress) ON (i.country);
CREATE INDEX alert_type_idx IF NOT EXISTS FOR (a:Alert) ON (a.type);
```

## Common Fraud Detection Queries

### 1. Velocity Check (Multiple Transactions in Short Time)
```cypher
MATCH (c:Card)-[:MADE]->(t1:Transaction)-[:FOLLOWED_BY]->(t2:Transaction)
WHERE t1.timestamp > datetime() - duration({hours: 24})
  AND duration.between(t1.timestamp, t2.timestamp).seconds < 300
  AND t1.amount > 100 AND t2.amount > 100
  AND t1.isOnline = true AND t2.isOnline = true
RETURN c, t1, t2
```

### 2. Geographic Anomaly Detection
```cypher
MATCH (c:Card)-[:MADE]->(t1:Transaction)-[:IN]->(l1:Location),
      (c)-[:MADE]->(t2:Transaction)-[:IN]->(l2:Location)
WHERE t1.timestamp > datetime() - duration({hours: 24})
  AND t2.timestamp > t1.timestamp
  AND duration.between(t1.timestamp, t2.timestamp).hours < 2
  AND point.distance(
    point({latitude: l1.latitude, longitude: l1.longitude}),
    point({latitude: l2.latitude, longitude: l2.longitude})
  ) > 500000  // 500 km in meters
RETURN c, t1, t2, l1, l2
```

### 3. Unusual Merchant Category
```cypher
MATCH (u:User)-[:OWNS]->(c:Card)-[:MADE]->(t:Transaction)-[:AT]->(m:Merchant)
WHERE t.timestamp > datetime() - duration({days: 7})
  AND NOT (u)-[:FREQUENTLY_VISITS]->(:Merchant {category: m.category})
  AND t.amount > 3 * u.averageTransactionAmount
RETURN u, c, t, m
```

### 4. Device/IP Anomaly
```cypher
MATCH (c:Card)-[:MADE]->(t:Transaction)-[:USING]->(d:Device)-[:FROM]->(ip:IPAddress)
WHERE t.timestamp > datetime() - duration({days: 1})
  AND (ip.isProxy = true OR ip.isVpn = true OR ip.isTor = true)
  AND NOT (c)-[:MADE]->(:Transaction)-[:USING]->(:Device)-[:FROM]->(ip)
RETURN c, t, d, ip
```

### 5. Card Testing Pattern
```cypher
MATCH (c:Card)-[:MADE]->(t:Transaction)
WHERE t.timestamp > datetime() - duration({hours: 1})
WITH c, count(t) as txCount, avg(t.amount) as avgAmount
WHERE txCount > 5 AND avgAmount < 10
RETURN c, txCount, avgAmount
```

### 6. Multiple Declined Transactions
```cypher
MATCH (c:Card)-[:MADE]->(t:Transaction)
WHERE t.timestamp > datetime() - duration({hours: 24})
  AND t.isDeclined = true
WITH c, count(t) as declinedCount
WHERE declinedCount >= 3
MATCH (c)-[:MADE]->(t:Transaction)
WHERE t.timestamp > datetime() - duration({hours: 24})
RETURN c, collect(t) as transactions, declinedCount
ORDER BY declinedCount DESC
```

### 7. Common Fraud Pattern Matching
```cypher
MATCH (t:Transaction)-[:SIMILAR_TO]->(fp:FraudPattern)
WHERE t.timestamp > datetime() - duration({days: 1})
  AND fp.confidence > 0.8
  AND t.fraudScore > 0.7
RETURN t, fp
```

### 8. Identifying Potential Fraud Rings
```cypher
MATCH (d:Device)<-[:USING]-(t:Transaction)<-[:MADE]-(c:Card)<-[:OWNS]-(u:User)
WITH d, count(DISTINCT u) as userCount
WHERE userCount > 3
MATCH (d)<-[:USING]-(t:Transaction)<-[:MADE]-(c:Card)<-[:OWNS]-(u:User)
RETURN d, collect(DISTINCT u) as users, collect(DISTINCT t) as transactions
```

## Time-Based Analysis

### 1. Transaction Timeline
```cypher
MATCH (c:Card)-[:MADE]->(t:Transaction)
WHERE c.cardId = 'card_123456'
RETURN t.timestamp, t.amount, t.merchantName
ORDER BY t.timestamp
```

### 2. User Activity Heatmap
```cypher
MATCH (u:User)-[:OWNS]->(c:Card)-[:MADE]->(t:Transaction)
WHERE u.userId = 'user_123456'
  AND t.timestamp > datetime() - duration({days: 30})
RETURN date(t.timestamp) as day, count(t) as transactionCount
ORDER BY day
```

## Graph Algorithms for Fraud Detection

### 1. PageRank for Risk Scoring
```cypher
CALL gds.pageRank.write(
  'fraud_graph',
  {
    maxIterations: 20,
    dampingFactor: 0.85,
    writeProperty: 'pageRank'
  }
)
YIELD nodePropertiesWritten, ranIterations
```

### 2. Community Detection for Fraud Rings
```cypher
CALL gds.louvain.write(
  'fraud_graph',
  {
    writeProperty: 'communityId'
  }
)
YIELD communityCount, modularity, modularities
```

### 3. Similarity Algorithms for Pattern Matching
```cypher
CALL gds.nodeSimilarity.write(
  'fraud_graph',
  {
    writeProperty: 'similarity',
    writeRelationshipType: 'SIMILAR',
    similarityCutoff: 0.5
  }
)
YIELD nodesCompared, relationshipsWritten
```

## Integration with GNN and GraphRAG

### 1. Feature Extraction for GNN
```cypher
MATCH (t:Transaction)
WHERE t.timestamp > datetime() - duration({days: 30})
CALL {
  WITH t
  MATCH (t)-[:AT]->(m:Merchant)
  MATCH (t)-[:IN]->(l:Location)
  MATCH (c:Card)-[:MADE]->(t)
  MATCH (u:User)-[:OWNS]->(c)
  OPTIONAL MATCH (t)-[:USING]->(d:Device)
  OPTIONAL MATCH (d)-[:FROM]->(ip:IPAddress)
  RETURN m.category as merchantCategory,
         m.riskScore as merchantRisk,
         l.country as country,
         u.riskScore as userRisk,
         CASE WHEN d IS NOT NULL THEN d.riskScore ELSE 0 END as deviceRisk,
         CASE WHEN ip IS NOT NULL THEN ip.riskScore ELSE 0 END as ipRisk
}
RETURN t.transactionId,
       t.amount,
       t.isOnline,
       merchantCategory,
       merchantRisk,
       country,
       userRisk,
       deviceRisk,
       ipRisk,
       t.isFraudulent as label
```

### 2. GraphRAG Context Retrieval
```cypher
// Find similar transactions to investigate
MATCH (t:Transaction {transactionId: 'tx_123456'})
MATCH (t)-[:AT]->(m:Merchant)
MATCH (c:Card)-[:MADE]->(t)
MATCH (u:User)-[:OWNS]->(c)

// Find similar transactions by same user
MATCH (u)-[:OWNS]->(otherCard:Card)-[:MADE]->(otherTx:Transaction)
WHERE otherTx.transactionId <> t.transactionId
  AND abs(otherTx.amount - t.amount) < 100
  AND duration.between(otherTx.timestamp, t.timestamp).days < 30

// Find similar transactions at same merchant
MATCH (otherUser:User)-[:OWNS]->(otherCard:Card)-[:MADE]->(merchantTx:Transaction)-[:AT]->(m)
WHERE otherUser <> u
  AND merchantTx.timestamp > datetime() - duration({days: 7})

// Find known fraud patterns
MATCH (t)-[:SIMILAR_TO]->(fp:FraudPattern)

RETURN t, u, c, m, 
       collect(DISTINCT otherTx) as similarUserTransactions,
       collect(DISTINCT merchantTx) as recentMerchantTransactions,
       collect(DISTINCT fp) as matchedFraudPatterns
```

## Data Maintenance and Optimization

### 1. Periodic Cleanup
```cypher
// Archive old transactions (older than 1 year)
MATCH (t:Transaction)
WHERE t.timestamp < datetime() - duration({years: 1})
  AND t.isFraudulent = false
SET t:ArchivedTransaction
REMOVE t:Transaction
```

### 2. Update Risk Scores
```cypher
// Update merchant risk scores based on fraud rate
MATCH (m:Merchant)<-[:AT]-(t:Transaction)
WITH m, count(t) as totalTx, sum(CASE WHEN t.isFraudulent THEN 1 ELSE 0 END) as fraudTx
WHERE totalTx > 10
SET m.fraudRate = toFloat(fraudTx) / totalTx,
    m.riskScore = CASE 
                    WHEN toFloat(fraudTx) / totalTx > 0.05 THEN 0.9
                    WHEN toFloat(fraudTx) / totalTx > 0.01 THEN 0.7
                    WHEN toFloat(fraudTx) / totalTx > 0.005 THEN 0.5
                    ELSE 0.2
                  END
```

## Performance Considerations

1. Use time-based partitioning for transaction data
2. Implement periodic index rebuilding
3. Use separate database instances for real-time vs. historical analysis
4. Implement caching for frequently accessed nodes
5. Use batch processing for large-scale graph updates
6. Consider sharding for extremely large datasets
