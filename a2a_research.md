# Agent to Agent (A2A) Protocol Research

## Overview
The Agent2Agent (A2A) protocol is an open protocol developed by Google that enables communication and interoperability between independent AI agents built on different frameworks and vendors. It provides a standardized way for agents to communicate with each other, share capabilities, and work together securely.

## Key Features
- Enables communication between independent AI agents across different ecosystems
- Provides a common language for multi-agent communication regardless of framework or vendor
- Allows agents to show each other their capabilities and negotiate interaction methods
- Supports various interaction modes (text, forms, bidirectional audio/video)
- Ensures secure collaboration between agents

## Core Concepts
1. **Agent Card**: A public metadata file (usually at `/.well-known/agent.json`) describing an agent's capabilities, skills, endpoint URL, and authentication requirements. Used for discovery.

2. **A2A Server**: An agent exposing an HTTP endpoint that implements the A2A protocol methods. It receives requests and manages task execution.

3. **A2A Client**: An application or another agent that consumes A2A services. It sends requests to an A2A Server's URL.

4. **Task**: The central unit of work. A client initiates a task by sending a message. Tasks have unique IDs and progress through states (`submitted`, `working`, `input-required`, `completed`, `failed`, `canceled`).

5. **Message**: Represents communication turns between the client (`role: "user"`) and the agent (`role: "agent"`). Messages contain `Parts`.

6. **Part**: The fundamental content unit within a `Message` or `Artifact`. Can be `TextPart`, `FilePart`, or `DataPart` (for structured JSON, e.g., forms).

7. **Artifact**: Represents outputs generated by the agent during a task (e.g., generated files, final structured data).

8. **Streaming**: For long-running tasks, servers can use streaming to provide real-time progress updates.

9. **Push Notifications**: Servers can proactively send task updates to a client-provided webhook URL.

## Typical Flow
1. **Discovery**: Client fetches the Agent Card from the server's well-known URL.
2. **Initiation**: Client sends a request containing the initial user message and a unique Task ID.
3. **Processing**: Server processes the task and provides updates (streaming or non-streaming).
4. **Interaction**: If the task requires input, the client sends subsequent messages.
5. **Completion**: The task eventually reaches a terminal state.

## Benefits for Fraud Detection
- Enables seamless communication between specialized fraud detection agents
- Allows agents with different capabilities (transaction analysis, user behavior analysis, etc.) to collaborate
- Supports real-time notification of suspicious activities between agents
- Provides structured data exchange for sharing fraud indicators
- Enables coordinated investigation and response to potential fraud

## Integration with Other Technologies
- Complements Model Context Protocol (MCP) which provides tools and context to agents
- Can be integrated with various agent frameworks including LangGraph
- Works with Neo4j for graph-based fraud pattern detection and investigation
- Enables multi-agent orchestration for comprehensive fraud detection
